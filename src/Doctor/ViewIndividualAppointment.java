package Doctor;
import Classes.Doctor;
import Classes.AppointmentServices;
import javax.swing.table.DefaultTableModel;
import java.io.File;
import javax.swing.*;
import javax.swing.table.*;
import java.nio.charset.StandardCharsets;


public class ViewIndividualAppointment extends javax.swing.JFrame {
    
    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(ViewIndividualAppointment.class.getName());

    /**
     * Creates new form ViewIndividualAppointment
     */
    private final DefaultTableModel model = new DefaultTableModel();
    
    private final String[] columns = {"ID","Customer","Doctor","Date/Time","Reason","Status"};
    private final Doctor currentDoctor;
    private final AppointmentServices svc = new AppointmentServices(new File("data/appointments.txt"));
    public ViewIndividualAppointment(Doctor currentDoctor) {
        this.currentDoctor = currentDoctor;
        model.setColumnIdentifiers(columns);
        initComponents();
        setLocationRelativeTo(null);
        tblAppointment.setModel(model);
        svc.loadAppointmentsForDoctor(model, this.currentDoctor.getId().trim());



        ensureActionColumn();
        
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        tblAppointment = new javax.swing.JTable();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jLabel1.setText("View Appointment");

        tblAppointment.setModel(model);
        jScrollPane1.setViewportView(tblAppointment);

        jButton1.setBackground(new java.awt.Color(204, 255, 255));
        jButton1.setText("Refresh");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setBackground(new java.awt.Color(0, 204, 204));
        jButton2.setText("Back");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 619, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(28, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButton2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButton1)
                        .addGap(45, 45, 45))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(26, 26, 26)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jButton1)
                    .addComponent(jButton2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 370, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(53, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    private void ensureActionColumn() {
        TableColumnModel cm = tblAppointment.getColumnModel();

        if (model.getColumnCount() == columns.length + 1 &&
            "Action".equals(model.getColumnName(model.getColumnCount() - 1))) {
            ActionCells();
            return;
        }

        model.addColumn("Action");
        ActionCells();

        int actionCol  = model.getColumnCount() - 1;
        int statusCol  = model.findColumn("Status"); // index of Status

        new ButtonColumn(tblAppointment, row -> {
            String appointmentId = String.valueOf(tblAppointment.getValueAt(row, 0)); // ID
            String customerId    = String.valueOf(tblAppointment.getValueAt(row, 1)); // Customer (must be Cxxxx)
            String dateTime      = String.valueOf(tblAppointment.getValueAt(row, 3)); // Date/Time

            java.awt.EventQueue.invokeLater(() -> {
                new DoctorFeedback(currentDoctor, appointmentId, dateTime, customerId).setVisible(true); // <-- 4 args
                ViewIndividualAppointment.this.dispose();
            });
        }, actionCol, r -> {
            Object s = (statusCol >= 0) ? tblAppointment.getValueAt(r, statusCol) : null;
            return s != null && "ASSIGNED".equalsIgnoreCase(s.toString().trim());
           }
        );

        cm.getColumn(actionCol).setPreferredWidth(80);
    }

    /** Put "View" text into each Action cell (so renderer/editor has content). */
    private void ActionCells() {
        int col = model.getColumnCount() - 1;
        for (int r = 0; r < model.getRowCount(); r++) {
            model.setValueAt("View", r, col);
        }
    }



    
    
    
    
    
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        svc.loadAppointmentsForDoctor(model, currentDoctor.getId());
        ActionCells();
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        new DoctorMainMenu(currentDoctor).setVisible(true);   // keep same doctor object
        this.dispose();
    }//GEN-LAST:event_jButton2ActionPerformed

    /**
     * @param args the command line arguments
     */

   




    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable tblAppointment;
    // End of variables declaration//GEN-END:variables
}
class ButtonColumn extends AbstractCellEditor
        implements TableCellRenderer, TableCellEditor, java.awt.event.ActionListener {

    private final JTable table;
    private final JButton renderButton = new JButton("View");
    private final JButton editButton   = new JButton("View");
    private final int column;
    private final java.util.function.IntConsumer onClick;
    private final java.util.function.IntPredicate isEnabledForRow; // NEW

    ButtonColumn(JTable table,
                 java.util.function.IntConsumer onClick,
                 int column,
                 java.util.function.IntPredicate isEnabledForRow) { // NEW
        this.table = table; this.onClick = onClick; this.column = column;
        this.isEnabledForRow = isEnabledForRow; // NEW
        editButton.addActionListener(this);

        TableColumnModel m = table.getColumnModel();
        m.getColumn(column).setCellRenderer(this);
        m.getColumn(column).setCellEditor(this);
    }

    @Override
    public java.awt.Component getTableCellRendererComponent(JTable t, Object v,
            boolean sel, boolean focus, int row, int col) {
        boolean enabled = isEnabledForRow == null || isEnabledForRow.test(row);
        renderButton.setEnabled(enabled); // NEW: show disabled look
        if (sel) {
            renderButton.setForeground(t.getSelectionForeground());
            renderButton.setBackground(t.getSelectionBackground());
        } else {
            renderButton.setForeground(t.getForeground());
            renderButton.setBackground(UIManager.getColor("Button.background"));
        }
        return renderButton;
    }

    @Override
    public java.awt.Component getTableCellEditorComponent(JTable t, Object v,
            boolean sel, int row, int col) {
        boolean enabled = isEnabledForRow == null || isEnabledForRow.test(row);
        editButton.setEnabled(enabled); // NEW: block clicks when not allowed
        return editButton;
    }

    @Override public Object getCellEditorValue() { return "View"; }

    @Override
    public void actionPerformed(java.awt.event.ActionEvent e) {
        int row = table.getEditingRow();
        fireEditingStopped();
        if (row >= 0 && (isEnabledForRow == null || isEnabledForRow.test(row))) {
            onClick.accept(row); // only fire when enabled
        }
    }
}
